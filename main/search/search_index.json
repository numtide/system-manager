{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#general-tips-and-best-practices","title":"General Tips and Best Practices","text":""},{"location":"faq/#1-always-test-in-a-vm-first","title":"1. Always Test in a VM First","text":"<p>Before applying changes to your production system, test in a safe environment:</p> <pre><code># Build the configuration first to check for errors\nnix build .#systemConfigs.default\n\n# For actual VM testing, use a tool like NixOS's VM builder\n# or test in a container/virtualized environment\n</code></pre>"},{"location":"faq/#2-use-flake-inputs-follows","title":"2. Use Flake Inputs Follows","text":"<p>This ensures consistent nixpkgs versions:</p> <pre><code>inputs = {\n  nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  system-manager = {\n    url = \"github:numtide/system-manager\";\n    inputs.nixpkgs.follows = \"nixpkgs\";  # Use the same nixpkgs\n  };\n};\n</code></pre> <p>By default, each flake input pins its own version of its dependencies, which means you could end up with multiple versions of <code>nixpkgs</code>. The <code>follows</code> directive tells Nix to use your <code>nixpkgs</code> instead of the one bundled with System Manager, ensuring consistent package versions across your entire configuration while reducing disk usage and evaluation time.</p>"},{"location":"faq/#3-modular-configuration","title":"3. Modular Configuration","text":"<p>Split your configuration into multiple files:</p> <pre><code>.\n\u251c\u2500\u2500 flake.nix\n\u2514\u2500\u2500 modules\n    \u251c\u2500\u2500 default.nix\n    \u251c\u2500\u2500 services.nix\n    \u251c\u2500\u2500 packages.nix\n    \u2514\u2500\u2500 users.nix\n</code></pre>"},{"location":"faq/#4-check-logs","title":"4. Check Logs","text":"<p>Always check systemd logs after activation:</p> <pre><code>sudo journalctl -u system-manager.target\nsudo journalctl -xe\n</code></pre>"},{"location":"faq/#5-garbage-collection","title":"5. Garbage Collection","text":"<p>Regularly clean up old generations:</p> <pre><code># Remove old system-manager profiles\nsudo nix-env --profile /nix/var/nix/profiles/system-manager-profiles --delete-generations old\n\n# Run garbage collection\nsudo nix-collect-garbage -d\n</code></pre>"},{"location":"faq/#6-rollback","title":"6. Rollback","text":"<p>If something goes wrong, you can rollback:</p> <pre><code># List generations\nsudo nix-env --profile /nix/var/nix/profiles/system-manager-profiles --list-generations\n\n# Rollback to previous generation\nsudo nix-env --profile /nix/var/nix/profiles/system-manager-profiles --rollback\n\n# Activate the previous generation\nnix run 'github:numtide/system-manager' -- activate --sudo\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#service-wont-start","title":"Service Won't Start","text":"<pre><code># Check service status\nsudo systemctl status &lt;service-name&gt;\n\n# View detailed logs\nsudo journalctl -u &lt;service-name&gt; -n 50\n\n# Check if service file exists\nls -la /etc/systemd/system/&lt;service-name&gt;.service\n</code></pre>"},{"location":"faq/#package-not-found-in-path","title":"Package Not Found in PATH","text":"<p>If you just installed System Manager, and installed a package through it, try logging out and logging back in to pick up the <code>PATH</code>.</p> <pre><code># Check if package is in the profile\nls -la /nix/var/nix/profiles/system-manager-profiles/*/bin/\n\n# Verify the package is in your config\ncat /etc/installed-packages.txt\n\n# Check $PATH\necho $PATH\n</code></pre>"},{"location":"faq/#permission-denied","title":"Permission Denied","text":"<p>Ensure you're running System Manager with sudo:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre>"},{"location":"faq/#configuration-wont-build","title":"Configuration Won't Build","text":"<pre><code># Check for syntax errors\nnix flake check\n\n# Build without activation\nnix build .#systemConfigs.default\n\n# View build logs\nnix log /nix/store/&lt;hash&gt;\n</code></pre>"},{"location":"faq/#additional-resources","title":"Additional Resources","text":"<ul> <li>System Manager GitHub Repository</li> <li>System Manager Documentation</li> <li>NixOS Module Options</li> <li>Nix Package Search</li> <li>PR #266: User Management with Userborn</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>If you've heard of NixOS, you've probably heard that it lets you define your entire system in configuration files and then reproduce that system anywhere with a single command. System Manager brings that same declarative model to other Linux distribution*, with no reinstalling, no switching operating systems, and no special prerequisites beyond having Nix installed.</p> <p>*Presently System Manager is only tested on Ubuntu, and is limited to only Linux distributions based on systemd.</p>"},{"location":"getting-started/#initializing-your-system","title":"Initializing Your System","text":"<p>Before proceeding, ensure you have installed Nix with flakes enabled.</p> <p>To get started with System Manager, run the init subcommand, which will create an initial set of files in the <code>~/.config/system-manager</code> folder:</p> <pre><code>nix run 'github:numtide/system-manager' -- init\n</code></pre> <p>(Remember, the double dash -- signifies that any options following it are passed to the following command, in this case System Manager, rather than to the main command, <code>nix</code>).</p> <p>You might see the following for questions; you can simply answer yes to them:</p> <ul> <li> <p>Do you want to allow configuration setting 'extra-substituters' to be set to 'https://cache.numtide.com' (y/N)?</p> </li> <li> <p>Do you want to permanently mark this value as trusted (y/N)?</p> </li> <li> <p>Do you want to allow configuration setting 'extra-trusted-public-keys' to be set to 'niks3.numtide.com-1:DTx8wZduET09hRmMtKdQDxNNthLQETkc/yaX7M4qK0g=' (y/N)?</p> </li> <li> <p>Do you want to permanently mark this value as trusted (y/N)?</p> </li> </ul> <p>After running the command you will have the following files in your <code>~/.config/system-manager</code> folder:</p> <ul> <li><code>flake.nix</code> -- A flake entrypoint that loads the system.nix file</li> <li><code>system.nix</code> -- The declarative file that describes what your system should look like.</li> </ul> <p>Tip</p> <p>Because this is your first time running System Manager, Nix will download and build several files, which might take some time. This only happens once, and in the future, System Manager will run very quickly.</p> <p>Here are the contents of the files that were created:</p>"},{"location":"getting-started/#flakenix","title":"flake.nix","text":"<pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        # Specify your system configuration modules here, for example,\n        # the path to your system.nix.\n        modules = [ \n            ./system.nix \n        ];\n\n        # Optionally specify extraSpecialArgs and overlays\n      };\n    };\n}\n</code></pre>"},{"location":"getting-started/#systemnix","title":"system.nix","text":"<pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    # Enable and configure services\n    services = {\n      # nginx.enable = true;\n    };\n\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        # pkgs.hello\n      ];\n\n      # Add directories and files to `/etc` and set their permissions\n      etc = {\n        # with_ownership = {\n        #   text = ''\n        #     This is just a test!\n        #   '';\n        #   mode = \"0755\";\n        #   uid = 5;\n        #   gid = 6;\n        # };\n        #\n        # with_ownership2 = {\n        #   text = ''\n        #     This is just a test!\n        #   '';\n        #   mode = \"0755\";\n        #   user = \"nobody\";\n        #   group = \"users\";\n        # };\n      };\n    };\n\n    # Enable and configure systemd services\n    systemd.services = { };\n\n    # Configure systemd tmpfile settings\n    systemd.tmpfiles = {\n      # rules = [\n      #   \"D /var/tmp/system-manager 0755 root root -\"\n      # ];\n      #\n      # settings.sample = {\n      #   \"/var/tmp/sample\".d = {\n      #     mode = \"0755\";\n      #   };\n      # };\n    };\n  };\n}\n</code></pre>"},{"location":"getting-started/#example-installinguninstalling-apps","title":"Example: Installing/Uninstalling Apps","text":"<p>First, let's build a configuration file that installs or uninstalls apps.</p> <p>Tip</p> <p>The idea is that the configuration file describes what the system should look like. Keep that in mind, as opposed to thinking that the configuration file \"installs software\" or \"uninstalls software.\"</p> <p>To get started, we'll create another <code>.nix</code> file that will install a single app. Then we'll run System Manager, and verify it's installed.</p> <p>Then to demonstrate what System Manager can do, we'll add another line to the configuration file with another app; run System Manager again, and again verify its installation.</p> <p>Then after that we'll remove one of the apps from the configuration file, run System Manager, and verify that the app is no longer installed.</p> <p>This will fully demonstrate the declarative nature of these configuration files.</p> <p>First, in the <code>~/.config/system-manager</code> folder, create a file <code>apps.nix</code> and place the following in it:</p> <pre><code>{ pkgs, ... }:\n{\n  nixpkgs.hostPlatform = \"x86_64-linux\";\n\n  environment.systemPackages = with pkgs; [\n    tldr\n  ];\n}\n</code></pre> <p>This configuration states that the system being configured should have the <code>tldr</code> app present, and if isn't, System Manager will install it. (Notice how we phrased that! We didn't just say this file installs the app. With <code>.nix</code> files, it's important to get into the mindset that they state what the system should look like.)</p> <p>Now add the file to the modules list in <code>flake.nix</code> by replacing this modules line:</p> <pre><code>-         modules = [ ./system.nix ];\n+         modules = [\n+             ./system.nix\n+             ./apps.nix\n+         ];\n</code></pre> <p>Note: By default, <code>system.nix</code> includes starter code and some commented out examples, and nothing else. So you can leave it in the list; in its original state, it doesn't do anything.</p> <p>Next, we'll run System Manager to apply the configuration.</p> <p>System Manager needs root privileges to modify <code>/etc</code>, manage systemd services, and create system profiles. Use the <code>--sudo</code> flag to run these operations via sudo:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre> <p>After a short moment, the <code>tldr</code> app should be installed on your system.</p> <p>Tip</p> <p>The first time you install software with System Manager, it adds a path to your <code>$PATH</code> variable by creating an entry in <code>/etc/profile.d/</code>. This won't take effect until you log out and back in; or you can source the file like so: <code>source /etc/profile.d/system-manager-path.sh</code> After that, you should find the <code>tldr</code> program: <code>which tldr</code> should yield <code>/run/system-manager/sw/bin//tldr</code>.</p> <p>Now to demonstrate the declarative feature of System Manager, let's add another app to the list. Here's a fun app called <code>cowsay</code>. Add a single line <code>cowsay</code> to the list passed into <code>systemPackages</code>:</p> <pre><code>{ pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    environment.systemPackages = with pkgs; [\n      tldr\n      cowsay\n    ];\n  };\n}\n</code></pre> <p>Run System Manager again with the same command as above, and you should now have <code>cowsay</code> on your system:</p> <pre><code>~/.config/system-manager$ cowsay Hello!\n ________\n&lt; Hello! &gt;\n --------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n~/.config/system-manager$\n</code></pre> <p>Remember, this is a declarative approach; System Manager did not re-install <code>tldr</code>. It looked at the list (<code>tldr</code>, <code>cowsay</code>) and compared it to what is currently installed. It saw that <code>tldr</code> is already installed, so it skipped that one. It saw <code>cowsay</code> is not installed, so it installed it, so that the system matches the configuration file.</p> <p>Now let's remove <code>cowsay</code> from the list of installed software. To do so, simply remove the line (or comment it out):</p> <pre><code>{ pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    environment.systemPackages = with pkgs; [\n      tldr\n    ];\n  };\n}\n</code></pre> <p>Notice this file now looks exactly as it did before adding in <code>cowsay</code>, meaning the system will now look like it did before adding in <code>cowsay</code>. Re-run System Manager and you'll see that <code>cowsay</code> is no longer installed.</p>"},{"location":"getting-started/#understanding-the-config-attribute-set","title":"Understanding the config attribute set","text":"<p>In the above example, we added attributes to the <code>systemPackages</code> set, which is a part of the <code>environment</code> attribute set, which in turn is part of the <code>config</code> attribute set.</p> <p>When System Manager runs, with the help of the Nix language, you can have multiple <code>config</code> attribute sets, and System Manager combines them into a single attribute set. This allows you to have different setups in separate files, and simply combine them side by side, only having to add on to this line:</p> <pre><code>        modules = [\n            ./system.nix\n            ./apps.nix\n        ];\n</code></pre> <p>However, you need to be careful. Suppose you have a different set of software you want to install, and you create a flake in another area in the filesystem with that software. It might not work the way you intend.</p> <p>With that second flake, System Manager will gather up any apps you have in the <code>systemPackages</code> attribute, and compare that to what it has already installed earlier. If the packages installed earlier aren't included, it will remove those packages. (That includes the apps you installed with the \"other\" flake.)</p> <p>In other words, you cannot have two separate flakes, one for one set of software, the other for a different set of software, and bounce between those flakes. System Manager will treat the second as requesting to uninstall what it installed earlier.</p> <p>To make the above work, your best bet is to create a single flake and add in individual files that contain the apps you want to install, and always run from that same location.</p>"},{"location":"getting-started/#concepts-for-people-new-to-nix","title":"Concepts for people new to Nix","text":""},{"location":"getting-started/#understanding-imperative-state-vs-declarative-state","title":"Understanding Imperative State vs Declarative State","text":"<p>Imperative state means you change the system by hand, step by step. You run commands like <code>apt install</code>, edit files under <code>/etc</code> with a text editor, toggle systemd services, and make changes as you think of them. You're telling the computer how to do something:</p> <p>\"Install this package, then edit this file, then restart this service.\"</p> <p>Each action mutates the system in place, and over time the machine can drift into a state that's hard to reproduce.</p> <p>(To \"mutate\" something simply means to change it in place. When a system mutates, its files, settings, or state are altered directly, step by step, rather than being reconstructed from a clean, known description.)</p> <p>Declarative state, on the other hand, means you don't tell the system how to do the steps \u2014 you tell it what you want the final system to look like, and the tool (System Manager, NixOS, Home Manager, etc.) figures out the steps automatically.</p> <p>\"This machine should have these packages, these <code>/etc</code> files, and these services enabled.\" When you activate that configuration, the tool builds the desired end state and applies it in a predictable, repeatable way.</p> <p>Here's A simple analogy:</p> <p>Imperative is like writing a recipe with every individual action: \"Chop onions. Heat pan. Add oil...\"</p> <p>Declarative is like saying, \"I want a finished lasagna,\" and the system knows how to assemble it reliably every time.</p> <p>Declarative state avoids drift, keeps everything versioned and reproducible, and makes rollback simple. Imperative state is flexible and quick, but much harder to track or repeat.</p> <p>Traditional programming languages are typically imperative in nature. </p> <p>If you're familiar with coding, a language like JavaScript is imperative in that you describe everything in a step by step fashion. A language like HTML is declarative in that you simply state what the web page should look like, without saying how to do it.</p>"},{"location":"getting-started/#a-note-about-objects-in-your-nix-files","title":"A note about objects in your <code>.nix</code> files","text":"<p>Nix gives you significant flexibility in creating your objects that you use inside a <code>.nix</code> file.</p> <p>For example, you could have a <code>config</code> object that looks like this:</p> <pre><code>config = {\n  nixpkgs = {\n    hostPlatform = \"x86_64-linux\";\n  }\n}\n</code></pre> <p>This declares an object stored as <code>config</code> with a single member called <code>nixpkgs</code>; that <code>nixpkgs</code> member then has a single member called <code>hostPlatform</code>, holding the string literal <code>\"x86_64-linux\"</code>.</p> <p>But Nix allows great flexilibyt in how you declare such objects. Consider the following:</p> <p><pre><code>  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n  }\n</code></pre> This creates the exact same object. Nix allows you to string together members with a dot between them, and it will construct the inner object accordingly.</p> <p>Note</p> <p>In the examples throughout this and other guides here, we use a mixture of the above syntax.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>To use System Manager, you need:</p> <ul> <li>A Linux machine. We've tested System Manager with Ubuntu both as standalone and under Windows Subsystem for Linux (WSL).</li> <li>At least 12GB Disk Space. However, we recommend at least 16GB, as you will be very tight for space with under 16GB. (This is primarily due to Nix; if you're using System Manager to configure, for example, small servers on the Cloud, 8GB simply won't be enough.)</li> <li>Nix installed system-wide with flakes enabled. (System Manager doesn't work with a per-user installation of Nix)</li> </ul> <p>Warning</p> <p>Rollback functionality is not yet fully implemented. While you can list and switch between generations manually, automatic rollback on failure is not available. Always test configuration changes in a VM or non-production environment first.</p>"},{"location":"install/#installing-nix","title":"Installing Nix","text":"<p>If you don't have Nix installed yet, use the official multi-user installer:</p> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon\n</code></pre> <p>After installation, open a new terminal or source the profile:</p> <pre><code>. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh\n</code></pre> <p>Verify the installation:</p> <pre><code>nix --version\n</code></pre>"},{"location":"install/#enabling-flakes","title":"Enabling Flakes","text":"<p>The official installer does not enable flakes by default. Add this line to <code>/etc/nix/nix.conf</code>:</p> <pre><code>experimental-features = nix-command flakes\n</code></pre> <p>Alternatively, you can pass the <code>--extra-experimental-features</code> option to each <code>nix</code> command, but this is less convenient.</p> <p>Tip</p> <p>For other installation options (platform-specific guides, CI/CD environments), see nix-install.com.</p>"},{"location":"install/#checking-your-installation","title":"Checking Your Installation","text":"<p>To check if Nix is installed system-wide (required for System Manager), run:</p> <pre><code>which nix\n</code></pre> <p>If the output shows a path in your home directory (e.g., <code>/home/username/.nix-profile/bin/nix</code>), Nix is installed per-user and won't work with System Manager. A system-wide installation shows <code>/nix/var/nix/profiles/default/bin/nix</code>.</p>"},{"location":"install/#running-system-manager","title":"Running System Manager","text":"<p>Because Nix can load code (called \"flakes\") remotely, you don't need to download or install System Manager. Simply running it the first time will automatically fetch it into the Nix Store (<code>/nix/store</code>).</p> <p>To get started, run:</p> <pre><code>nix run 'github:numtide/system-manager' -- init\n</code></pre> <p>This will create initial configuration files in <code>~/.config/system-manager/</code>. See Getting Started for a complete walkthrough.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Declarative system configuration for Linux distributions.</p> <p>System Manager brings the power of NixOS-style declarative configuration to other Linux distributions. Define your packages, services, and <code>/etc</code> files in Nix, and System Manager ensures your system matches that configuration.</p>"},{"location":"introduction/#why-system-manager","title":"Why System Manager?","text":"<ul> <li>No reinstall required - Keep your existing distro (Ubuntu, Debian, Fedora, etc.) while gaining declarative configuration</li> <li>Reproducible systems - Your configuration files fully describe your system state</li> <li>Generational rollback - Switch between previous configurations when needed</li> <li>Familiar to NixOS users - Uses the same module system and configuration patterns</li> </ul>"},{"location":"introduction/#who-is-it-for","title":"Who is it for?","text":"<p>System Manager is ideal for:</p> <ul> <li>Developers who want reproducible development environments</li> <li>Sysadmins managing fleets of non-NixOS Linux servers</li> <li>NixOS users who need to configure systems where NixOS isn't an option</li> <li>Anyone tired of imperative configuration drift</li> </ul>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Configure your first system</li> <li>Installation - Install Nix and get started</li> <li>Examples - See practical use cases</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This reference documentation provides detailed information about System Manager's features and configuration options.</p>"},{"location":"reference/#sections","title":"Sections","text":""},{"location":"reference/#cli-commands","title":"CLI Commands","text":"<p>Command-line usage and all available subcommands: <code>init</code>, <code>switch</code>, <code>register</code>, <code>build</code>, <code>deactivate</code>, <code>pre-populate</code>, and <code>sudo</code>. Also covers optional local installation.</p>"},{"location":"reference/#configuration","title":"Configuration","text":"<p>How to organize your System Manager project: folder structure, file organization, workflows for getting started, managing <code>/etc/nix/nix.conf</code>, and running in non-interactive settings.</p>"},{"location":"reference/#modules","title":"Modules","text":"<p>Writing <code>.nix</code> configuration modules: the <code>flake.nix</code> structure, managing systemd services, installing packages, creating <code>/etc</code> files, and configuring tmpfiles.</p>"},{"location":"reference/#remote-flakes","title":"Remote Flakes","text":"<p>Hosting your configuration in a Git repository: understanding <code>flake.lock</code>, setting up remote hosting, and running System Manager from GitHub.</p>"},{"location":"reference/#blueprint","title":"Blueprint","text":"<p>Using the Blueprint library with System Manager for a standardized project structure.</p>"},{"location":"reference/#examples","title":"Examples","text":"<p>Complete, working examples:</p> <ul> <li>PostgreSQL - Database server setup</li> <li>Nginx - HTTP web server</li> <li>Nginx HTTPS - HTTPS with SSL certificates</li> <li>Custom App - Deploying a Bun/TypeScript application</li> </ul>"},{"location":"reference/blueprint/","title":"Blueprint","text":"<p>Blueprint is an opinionated library that maps a standard folder structure to flake outputs, allowing you to divide up your flake into individual files across these folders. This allows you to modularize and isolate these files so that they can be maintained individually and even shared across multiple projects.</p> <p>Blueprint has built-in support for System Manager, which means:</p> <ul> <li>You do not need to call <code>system-manager.lib.makeSystemConfig</code>; Blueprint calls this for you</li> <li>You must follow Blueprint's folder structure by placing your files under the <code>hosts</code> folder, and you must name your files <code>system-configuration.nix</code>.</li> <li>You can have multiple folders under the <code>hosts</code> folder (but one level deep), and you can access these using the standard nix specifier, e.g. <code>.#folder-name</code>.</li> </ul> <p>In this section we show you how to use Blueprint with System Manager.</p> <p>Blueprint provides its own initialization that you can start with if you don't already have a <code>flake.nix</code> file using Blueprint. The command to type is:</p> <pre><code>nix flake init -t github:numtide/blueprint\n</code></pre> <p>This results in the following flake:</p> <pre><code>{\n  description = \"Simple flake with a devshell\";\n\n  # Add all your dependencies here\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs?ref=nixos-unstable\";\n    blueprint.url = \"github:numtide/blueprint\";\n    blueprint.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  # Load the blueprint\n  outputs = inputs: inputs.blueprint { inherit inputs; };\n}\n</code></pre> <p>Now add System Manager to its inputs section:</p> <pre><code>    system-manager = {\n        url = \"github:numtide/system-manager\";\n        inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n</code></pre> <p>Next, create a folder called <code>hosts</code>, and under that a folder called <code>default</code>:</p> <pre><code>mkdir -p hosts/default\ncd hosts/default\n</code></pre> <p>Inside <code>default</code> is where you'll put your configuration file.</p> <p>This configuration file must be named <code>system-configuration.nix</code>.</p> <p>For example, here's a configuration file that installs <code>bat</code>:</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.bat\n      ];\n    };\n  };\n}\n</code></pre> <p>Note</p> <p>Notice that we need to include <code>nixpkgs.hostPlatform</code> in this file, as there's no place to include it in the parent <code>flake.nix</code> file.</p> <p>Now return to the folder two levels up (the one containing <code>flake.nix</code>) and you can run System Manager:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre> <p>Remember</p> <p>As mentioned elsewhere, if this is the first time running System Manager on this computer, you'll need to log out and log back in to pick up the new path.</p> <p>Then you should find <code>bat</code> on your path:</p> <pre><code>$ which bat\n/run/system-manager/sw/bin//bat\n</code></pre> <p>The default folder is called <code>default</code>; you can also refer to folders by name as mentioned earlier.</p> <p>If, for example, under the <code>hosts</code> folder you have a folder called <code>tree</code>, and inside <code>tree</code> you create a file called <code>system-configuration.nix</code> with the following contents:</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.tree\n      ];\n    };\n  };\n}\n</code></pre> <p>Then you can choose to install <code>tree</code> by specifying the <code>tree</code> folder like so:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake '.#tree' --sudo\n</code></pre>"},{"location":"reference/blueprint/#using-multiple-configuration-files-with-blueprint","title":"Using multiple configuration files with Blueprint","text":"<p>If you want to load multiple configuration files at once, you can create a special <code>system-configuration.nix</code> file that loads multiple files from a <code>modules</code> folder (or any name you choose). To accomplish this, create a folder under <code>hosts</code>; for example, you might name it <code>cli-tools</code>. Starting in the folder with <code>flake.nix</code>:</p> <pre><code>mkdir -p hosts/cli-tools/modules\n</code></pre> <p>Then, inside the <code>cli-tools</code> folder, create a <code>system-configuration.nix</code> file with the following:</p> <pre><code>{ config, lib, pkgs, ... }:\n{\n  # Import all your modular configs - they auto-merge!\n  imports = [\n    ./modules/tldr.nix\n    ./modules/cowsay.nix\n  ];\n\n  # Base configuration that applies to everything\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n  };\n}\n</code></pre> <p>(Notice this time we can put the <code>nixpkgs.hostPlatform</code> in a single place. As such we won't need it in the configuration files.)</p> <p>Now move into the <code>modules</code> folder:</p> <pre><code>cd modules\n</code></pre> <p>And create two files here:</p> <p>tldr.nix:</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.tldr\n      ];\n    };\n  };\n}\n</code></pre> <p>cowsay.nix: <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.cowsay\n      ];\n    };\n  };\n}\n</code></pre></p> <p>Now you can return to the top level where your <code>flake.nix</code> file is and run these two configuration files:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake '.#cli-tools' --sudo\n</code></pre> <p>This means if you want to include various recipes, you can easily do so.</p>"},{"location":"reference/cli/","title":"CLI Commands","text":"<p>The basic command looks like this:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre> <p>This is the most common scenario you'll use.</p>"},{"location":"reference/cli/#command-line-options","title":"Command-line Options","text":""},{"location":"reference/cli/#init","title":"init","text":"<p>This subcommand creates two initial files for use with System Manager, a fully-functional <code>flake.nix</code>, and a <code>system.nix</code> file that contains skeleton code.</p>"},{"location":"reference/cli/#command-line-options_1","title":"Command line options","text":"<p>path: The path where to create the files. If the path doesn't exist, it will be created.</p>"},{"location":"reference/cli/#example","title":"Example","text":"<pre><code>nix run 'github:numtide/system-manager' -- init\n</code></pre> <p>This will create the initial files in <code>~/.config/system-manager</code>.</p> <pre><code>nix run 'github:numtide/system-manager' -- init --path='/home/ubuntu/system-manager'\n</code></pre> <p>This will create the initial files in <code>/home/ubuntu/system-manager</code>.</p> <p>Note</p> <p>System Manager requires flakes to be enabled in <code>/etc/nix/nix.conf</code>. See Enabling Flakes for setup instructions.</p>"},{"location":"reference/cli/#switch","title":"switch","text":"<p>The <code>switch</code> subcommand builds and activates your configuration immediately, making it both the current running configuration and the default for future boots. Use it whenever you want to apply your changes.</p> <p>Note: Rollbacks are not yet implemented.</p> <p>The following two parameters are currently both required:</p> <p>--flake: Specifies a flake to use for configuration.</p> <p>--sudo: Specifies that System Manager can use sudo.</p>"},{"location":"reference/cli/#register","title":"register","text":"<p>The <code>register</code> subcommand builds and registers a System Manager configuration, but does not activate it. Compare this to <code>switch</code>, which does everything register does, but then activates it.</p>"},{"location":"reference/cli/#build","title":"build","text":"<p>The <code>build</code> subcommand builds everything needed for a switch, but does not register it.</p>"},{"location":"reference/cli/#deactivate","title":"deactivate","text":"<p>The <code>deactivate</code> deactivates System Manager.</p>"},{"location":"reference/cli/#pre-populate","title":"pre-populate","text":"<p>The <code>pre-populate</code> subcommand puts all files defined by the given generation in place, but does not start the services. This is useful in scripts.</p>"},{"location":"reference/cli/#sudo","title":"sudo","text":"<p>The <code>sudo</code> subcommand grants sudo access to System Manager, while running under the current user. All created files will be owned by the current user.</p>"},{"location":"reference/cli/#optional-installing-system-manager-locally","title":"Optional: Installing System Manager Locally","text":"<p>Nix allows you to run code that's stored remotely in a repo, such as in GitHub. As such, you don't have to install System Manager locally to use it. However, if you want to install locally, you can do so with the following <code>nix profile</code> command.</p> <pre><code>nix profile add 'github:numtide/system-manager'\n</code></pre> <p>Or, if you don't have the optional features set in <code>/etc/nix/nix.conf</code>, you can provide them through the command line:</p> <pre><code>nix profile add 'github:numtide/system-manager' --extra-experimental-features 'nix-command flakes'\n</code></pre> <p>Tip</p> <p>After System Manager is installed locally, you no longer need to worry about whether you have experimental features installed. You will simply pass the <code>--flake</code> option to System Manager.</p> <p>When you install System Manager, you might get some warnings about trusted user; this simply means you're not in the trusted user list of Nix. But System Manager will still install and work fine.</p> <p>Then you can find System Manager:</p> <pre><code>$ which system-manager\n/home/ubuntu/.nix-profile/bin/system-manager\n</code></pre> <p>And you can run System Manager:</p> <pre><code>system-manager switch --flake . --sudo\n</code></pre> <p>Tip</p> <p>System Manager is still in an early state and undergoing active development. Installing locally will not immediately pick up new changes. If you decide to install locally, you'll want to periodically check our GitHub repo for changes, and upgrade it if necessary by using <code>nix profile upgrade</code>.</p>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>This guide covers how to organize your System Manager project and recommended workflows for different scenarios.</p>"},{"location":"reference/configuration/#setting-up-a-folder-and-file-structure","title":"Setting up a folder and file structure","text":"<p>Before you begin with System Manager, you'll need to decide on your folder structure.</p> <p>Note</p> <p>If you prefer, you can host all your System Manager configuration files on a remote Git repo (such as GitHub), and then you don't need to worry about where on your computer to store the files. For more info, see Working with Remote Flakes.</p> <p>Technically, you are free to set up your folders and files however you like; System Manager does not enforce any rules, thus allowing you full flexibility. Below are simply some options that we recommend.</p> <p>Tip</p> <p>While you are free to have different System Manager <code>.nix</code> files scattered throughout your system, we recommend, if possible, keeping them in a single location simply for organizational purposes. But again, this is just a recommendation and you're not bound by any such rules.</p>"},{"location":"reference/configuration/#deciding-on-a-folder-structure","title":"Deciding on a folder structure","text":"<p>You'll need to choose where your System Manager configuration will live. Here are two main organizational patterns we recommend.</p> <ul> <li>Option A: A single folder for all your configuration</li> </ul> <p>A single folder keeps everything together. This offers a clean long-term solution, along with easy version control. It's also convenient for replicating between machines.</p> <ul> <li>Option B: A separate folder for each use case</li> </ul> <p>While not as common, it's entirely possible to organize your System Manager configuration into multiple independent folders, each focused on a specific use case. In this model, you treat each configuration as its own standalone unit, often stored in its own Git repository.</p> <p>For example, you might keep:</p> <ul> <li> <p>a dedicated configuration folder strictly for managing nginx,</p> </li> <li> <p>another for custom systemd services,</p> </li> <li> <p>another for developer tools,</p> </li> <li> <p>and yet another for monitoring and observability packages.</p> </li> </ul> <p>In this manner, you can then build up a system by picking and choosing which services you need for a particular machine, and pull each one down from GitHub.</p> <p>To make this happen, however, requires careful consideration as we discuss later.</p>"},{"location":"reference/configuration/#choosing-a-location","title":"Choosing a location","text":""},{"location":"reference/configuration/#option-1-your-personal-config-folder","title":"Option 1: Your personal ~/.config folder","text":"<p>If you're managing a system yourself and only you will be using it, one possibility is to put the files in <code>~/.config/system-manager</code>.</p> <p>This approach keeps everything scoped to you and avoids having to place files under <code>/etc</code> and, perhaps most importantly, avoids having to use sudo. Here's an example layout:</p> <pre><code>~/.config/system-manager/\n  flake.nix\n  modules/\n    default.nix\n</code></pre> <p>Tip</p> <p>Avoid this location if multiple people use the machine or if this configuration is meant to be shared with a team. Home-directory paths are user-specific and may not make sense across machines.</p>"},{"location":"reference/configuration/#option-2-a-shared-etcsystem-manager-folder-recommended-for-multi-user-or-organizational-setups","title":"Option 2: A shared <code>/etc/system-manager</code> folder (Recommended for multi-user or organizational setups)","text":"<p>If you are:</p> <ul> <li> <p>managing multiple machines,</p> </li> <li> <p>part of a team,</p> </li> <li> <p>deploying configurations in a corporate or server environment,</p> </li> <li> <p>or simply want a clear system-level location,</p> </li> </ul> <p>then <code>/etc/system-manager</code> is a great choice. Among the advantages are consistency across all machines; standard within an organization; and treating system manager as a system-level tool rather than a personal configuration. Here's an example layout:</p> <pre><code>/etc/system-manager/\n  flake.nix\n  modules/\n    default.nix\n    services.nix\n</code></pre>"},{"location":"reference/configuration/#choosing-a-file-structure","title":"Choosing a file structure","text":"<p>After choosing where your configuration lives, you must decide how to structure the files inside it. And note that while System Manager does not enforce any rules, we do recommend you maintain consistency, especially if you have multiple locations on your computer where you store System Manager <code>.nix</code> files.</p> <p>Essentially, you have two options:</p> <ul> <li> <p>A single <code>flake.nix</code> file</p> </li> <li> <p>A reusable <code>flake.nix</code> file with one or more separate configuration files that describe what the system will look like.</p> </li> </ul> <p>Within Option B, you can also use our open-source Blueprint product to help you manage your files, which we'll cover shortly.</p>"},{"location":"reference/configuration/#option-a-single-flakenix-file","title":"Option A: Single <code>flake.nix</code> file","text":"<p>This configuration is ideal for:</p> <ul> <li> <p>Small, simple setups</p> </li> <li> <p>Demos and experiments</p> </li> <li> <p>One-off configurations</p> </li> </ul> <p>Drawback: This approach doesn't scale well once you need multiple services, multiple hosts, or reusable modules.</p>"},{"location":"reference/configuration/#option-b-flake-file-with-one-or-more-configuration-files","title":"Option B: Flake file with one or more configuration files","text":"<p>This is the structure used by most production setups and by NixOS itself. Your arrangement might look like:</p> <pre><code>system-manager/\n  flake.nix\n  modules/\n    default.nix\n    services.nix\n    users.nix\n</code></pre> <p>Or, perhaps you might have separate services, one per file:</p> <pre><code>system-manager/\n  flake.nix\n  modules/\n    default.nix\n    service-1.nix\n    service-2.nix\n    users.nix\n</code></pre> <p>This also lends itself well to having multiple \"recipes\". For example, you might want to add nginx and postgres to your system. You might have them preconfigured somewhere, and simply \"drop\" them in like so:</p> <pre><code>system-manager/\n  flake.nix\n  modules/\n    default.nix\n    service-1.nix\n    service-2.nix\n    users.nix\n    nginx.nix\n    postgres.nix\n</code></pre> <p>Tip</p> <p>This is the approach we use in our examples in this document. That way each isolated \"recipe\" is repeatable and can be re-used across multiple systems.</p>"},{"location":"reference/configuration/#dealing-with-conflicting-nix-files","title":"Dealing with conflicting <code>.nix</code> files","text":"<p>If you have multiple flakes throughout your computer, you can run into a situation where one might install some software, and the other might install a different software -- but uninstall what was in the other configuration.</p> <p>For example; suppose you have one configuration file that includes this list of apps:</p> <pre><code>    environment = {\n      systemPackages = [\n        pkgs.bat\n        pkgs.nginx\n        pkgs.mysql84\n      ];\n</code></pre> <p>And you run System Manager, which installs the three apps.</p> <p>Then you separately in another folder have another flake with a different configuration and set of apps:</p> <pre><code>    environment = {\n      systemPackages = [\n        pkgs.hello\n        pkgs.postgresql_18\n        pkgs.vscode\n      ];\n</code></pre> <p>Then in this folder your run System Manager.</p> <p>System Manager does not track files, and see this as a changed configuration:</p> <ul> <li>The configuration no longer has <code>bat</code>, <code>nginx</code>, and <code>mysql84</code>.</li> <li>The configuration does have <code>hello</code>, <code>postgresql_18</code>, and <code>vscode</code>.</li> </ul> <p>The end result is that System Manager will remove <code>bat</code>, <code>nginx</code>, and <code>mysql84</code>, and install <code>hello</code>, <code>postgresql_18</code>, and <code>vscode</code>.</p> <p>The fix to this problem is to instead have a single main <code>flake.nix</code> file, which loads all of the different <code>.nix</code> files, allowing you to run System Manager from a single location.</p> <p>This is because Nix has the ability to merge together objects in separate files into a single object; the above would then merge into:</p> <pre><code>      systemPackages = [\n        pkgs.bat\n        pkgs.nginx\n        pkgs.mysql84\n        pkgs.hello\n        pkgs.postgresql_18\n        pkgs.vscode\n      ];\n</code></pre> <p>We describe this technique in Building System Manager <code>.nix</code> Files.</p>"},{"location":"reference/configuration/#letting-system-manager-manage-etcnixnixconf","title":"Letting System Manager manage <code>/etc/nix/nix.conf</code>","text":"<p>System Manager can optionally manage your <code>/etc/nix/nix.conf</code> file for you.</p> <p>If you have an existing <code>/etc/nix/nix.conf</code> file, you'll need to delete it if you want System Manager to manage the file; then run System Manager again. From that point on System Manager will manage the file for you, and you should not make changes to it.</p> <p>Instead, you'll put the changes in one of your <code>.nix</code> files you'll be building to configure System Manager.</p>"},{"location":"reference/configuration/#recommended-workflow-for-starting-out","title":"Recommended Workflow for Starting Out","text":"<p>As described previously, System Manager wants to manage your <code>/etc/nix/nix.conf</code> file for you, after which you can instead place your configurations directly in the <code>flake.nix</code> file, including specifying experimental features.</p> <p>To do so requires a careful set of steps. Follow these steps precisely when starting out with a fresh system.</p> <p>Note</p> <p>We will first run System Manager to create an initial <code>flake.nix</code> and <code>system.nix</code> file; we will then delete the <code>/etc/nix/nix.conf</code> file, and instead add the flags to the <code>flake.nix</code> file. Then we will run System Manager again to start managing your system, including the <code>/etc/nix/nix.conf</code> file.</p> <ol> <li>Temporarily run System Manager with <code>init</code> with experimental features enabled by including the following line in <code>/etc/nix/nix.conf</code>; this way <code>init</code> will generate a <code>flake.nix</code> file:</li> </ol> <pre><code>experimental-features = nix-command flakes\n</code></pre> <p>And then running System Manager with the init subcommand:</p> <pre><code>nix run 'github:numtide/system-manager' -- init\n</code></pre> <p>(For this step, do not simply add the flag for experimental features; otherwise <code>init</code> won't create the <code>flake.nix</code> file.)</p> <ol> <li>Under <code>~/.config/system-manager</code>, edit the <code>flake.nix</code> file, replacing this line:</li> </ol> <pre><code>  modules = [ ./system.nix ];\n</code></pre> <p>with this:</p> <pre><code>modules = [\n    {\n        nix.settings.experimental-features = \"nix-command flakes\";\n    }\n    ./system.nix\n];\n</code></pre> <ol> <li>Delete the <code>/etc/nix/nix.conf</code> file, optionally backing it up first:</li> </ol> <pre><code>sudo cp /etc/nix/nix.conf /etc/nix/nix_old # optional\nsudo rm /etc/nix/nix.conf\n</code></pre> <ol> <li>Run System Manager to initialize your system, with the experimental flags set this one time in the command-line:</li> </ol> <pre><code>cd ~/.config/system-manager\nnix run 'github:numtide/system-manager' --extra-experimental-features 'nix-command flakes' -- switch --flake . --sudo\n</code></pre> <p>System Manager is now managing your system for you, including the <code>/etc/nix/nix.conf</code> file. And experimental features are required and turned on through the <code>flake.nix</code> file, meaning you do not need to include the <code>--extra-experimental-features</code> option when you run System Manager:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre> <p>Next, if you want to make sure experimental features are always on, you can add it to your flake.</p>"},{"location":"reference/configuration/#using-system-manager-in-a-non-interactive-setting","title":"Using System Manager in a non-Interactive Setting","text":"<p>If you're running System Manager in a non-interative script, you might run into a problem with the four questions presented when you first run it:</p> <ul> <li> <p>Do you want to allow configuration setting 'extra-substituters' to be set to 'https://cache.numtide.com' (y/N)?</p> </li> <li> <p>Do you want to permanently mark this value as trusted (y/N)?</p> </li> <li> <p>Do you want to allow configuration setting 'extra-trusted-public-keys' to be set to 'niks3.numtide.com-1:DTx8wZduET09hRmMtKdQDxNNthLQETkc/yaX7M4qK0g=' (y/N)?</p> </li> <li> <p>Do you want to permanently mark this value as trusted (y/N)?</p> </li> </ul> <p>The reason for these questions is Numtide has made pre-built binary versions of System Manager available from our cache, which speeds up performance since your system doesn't have to build System Manager from source. However, this triggers Nix to ask these four questions. You'll most likely want to answer \"y\" to all four.</p> <p>But doing so can cause problems with a non-interactive script. To run System Manager in a script, you can simply add the <code>--accept-flake-config</code> option like so:</p> <pre><code>nix run 'github:numtide/system-manager' --accept-flake-config --extra-experimental-features 'nix-command flakes' -- switch --flake . --sudo\n</code></pre> <p>If you like, you can add these settings into your flake file, such as in the following:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        modules = [\n            {\n                nix.settings.experimental-features = \"nix-command flakes\";\n                nix.settings.extra-substituters = https://cache.numtide.com;\n                nix.settings.extra-trusted-public-keys = niks3.numtide.com-1:DTx8wZduET09hRmMtKdQDxNNthLQETkc/yaX7M4qK0g=;\n            }\n            ./glow.nix\n        ];\n      };\n    };\n}\n</code></pre> <p>Remember, however, the flake shows what the system looks like after System Manager runs. That means these changes won't affect the first run of System Manager, which in this case is likely through a script. As such, the first time you run System Manager, you'll still need the <code>--accept-flake-config</code> option. Then on subsequent runs you don't need the <code>--accept-flake-config</code> option.</p>"},{"location":"reference/configuration/#recommended-workflow-if-you-already-have-your-nix-files","title":"Recommended Workflow if You Already Have Your Nix Files","text":"<p>If you already have your <code>.nix</code> files, you don't need to run the <code>init</code> subcommand. Instead, we recommend the following if you're starting out on a clean system:</p> <ol> <li> <p>Remove the <code>/etc/nix/nix.conf</code> file. Then, when you run System Manager the first time, System Manager will take control managing this file for you. You can then place any configuration you previously had in the <code>/etc/nix/nix.conf</code> file in your <code>.nix</code> files.</p> </li> <li> <p>Run System Manager the first time, and you'll be ready to go.</p> </li> </ol> <p>As an example, here's a starting <code>flake.nix</code> file:</p> <p>flake.nix <pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        modules = [\n            {\n                nix.settings.experimental-features = \"nix-command flakes\";\n            }\n            ./glow.nix\n        ];\n      };\n    };\n}\n</code></pre></p> <p>Notice that we've included in the modules list an object that sets experimental features, turning on flakes.</p> <p>Now here's the <code>glow.nix</code> file referenced above; it simply installs the <code>glow</code> command, which is for displaying markdown files in a shell:</p> <p>glow.nix</p> <pre><code>{ pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    environment.systemPackages = with pkgs; [\n        glow\n    ];\n  };\n}\n</code></pre> <p>Go ahead and delete <code>/etc/nix/nix.conf</code>:</p> <pre><code>sudo rm /etc/nix/nix.conf\n</code></pre> <p>And now run System Manager. Because you removed <code>nix.conf</code>, you'll need to turn on experimental features as a command-line option.</p> <pre><code>nix run 'github:numtide/system-manager' --extra-experimental-features 'nix-command flakes' -- switch --flake . --sudo\n</code></pre> <p>After System Manager runs, you'll have the changes in place (in this case the <code>glow</code> command added), and you'll be able to manage features, including experimental features, through your flake. And because you turned on the flakes experimental features, future runs of System Manager no longer need the flags. You can simply run:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre>"},{"location":"reference/modules/","title":"Modules","text":"<p>This guide covers how to write <code>.nix</code> configuration modules for System Manager, including services, packages, <code>/etc</code> files, and tmpfiles.</p>"},{"location":"reference/modules/#building-system-manager-nix-files","title":"Building System Manager <code>.nix</code> files","text":"<p>Ready for an example! For this example, we're going to use the following:</p> <ul> <li> <p>Our files will live in <code>~/.config/system-manager</code></p> </li> <li> <p>We'll have two files, one <code>flake.nix</code>, and <code>system.nix</code></p> </li> </ul> <p>Note that we'll be using the files generated by System Manager's <code>init</code> subcommand. But to show that we're not locked into that format, later we'll demonstrate a single <code>flake.nix</code> file. Then in the sections that follow, we'll demonstrate how you can further split up your files.</p> <p>We'll demonstrate how to install an app on your machine, then we'll add another app, then we'll uninstall the first app.</p> <p>We'll also demonstrate how to move items from your <code>/etc/nix/nix.conf</code> file into your System Manager configuration file.</p>"},{"location":"reference/modules/#the-main-flakenix-file","title":"The Main <code>flake.nix</code> File","text":"<p>We recommend you start with a basic <code>flake.nix</code> file similar to this:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        # Specify your system configuration modules here, for example,\n        # the path to your system.nix.\n        modules = [ ./system.nix ];\n\n        # Optionally specify extraSpecialArgs and overlays\n      };\n    };\n}\n</code></pre> <p>This is a typical flake with an <code>inputs</code> and an <code>outputs</code> section. The inputs loads in <code>nixpkgs</code> and <code>system-manager</code>. The outputs part has one primary job: It calls System Manager's <code>makeSystemConfig</code> function, passing in any number of <code>.nix</code> modules.</p> <p>Each module, in turn, must specify a <code>config</code> object, containing configuration settings. These can be in separate files, and Nix will merge them into a single <code>config</code> object that gets passed into <code>makeSystemConfig</code>.</p> <p>Your <code>config</code> attribute set can have:</p> <ul> <li><code>nixpkgs.hostPlatform</code>: This specifies the platform such as <code>nixpkgs.hostPlatform = \"x86_64-linux\";</code></li> <li><code>environment</code>, consisting of</li> <li><code>systemPackages</code></li> <li><code>etc</code></li> <li><code>systemd.services</code></li> <li><code>systemd.tmpfiles</code></li> </ul> <p>For example, you could then replace the</p> <pre><code>modules = [ ./system.nix ];\n</code></pre> <p>line with individual <code>.nix</code> files. For example, you might have one file that installs the <code>bat</code> command, and another file that installs the <code>tree</code> command.</p> <p>As an example, let's put these two files in a <code>modules</code> folder under the folder holding <code>flake.nix</code>. Replace the modules line with this:</p> <pre><code>modules = [\n  {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n  }\n  ./modules/tree.nix\n  ./modules/bat.nix\n];\n</code></pre> <p>Then here are the individual \"recipe\" files.</p> <p>modules/bat.nix</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.bat\n      ];\n    };\n  };\n}\n</code></pre> <p>modules/tree.nix</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.tree\n      ];\n    };\n  };\n}\n</code></pre> <p>Why take this approach? Because you could, for example, have many different recipes stored in a GitHub repo (or anywhere, really), and you could easily drop them into your system, adding a single line in <code>flake.nix</code> for each. Each one would have their own software installations. And this solves the problem described in Dealing with Conflicting <code>.nix</code> Files</p>"},{"location":"reference/modules/#managing-system-services","title":"Managing System Services","text":"<p>System Manager lets you manage systemd services declaratively, using the same module language you used for installing packages or creating files under <code>/etc</code>. Instead of manually placing service files in <code>/etc/systemd/system</code> or enabling them with <code>systemctl</code>, you describe the service in a Nix module--its command, environment, dependencies, restart behavior, and any timers or sockets it needs.</p> <p>System Manager then generates the correct systemd unit files, installs them into the right directory, and reloads systemd automatically during a switch. This approach gives you repeatability and safety: if you rebuild a machine, the same services come back exactly as before; if a service configuration breaks, you simply roll back to the previous generation. Declarative service management also avoids drift--no accidental edits, no forgotten manual steps, and no inconsistencies between machines or team members.</p> <p>Using this approach, instead of manually saving a file in <code>/etc/systemd/system</code> and then manually starting and stopping the service, you use a <code>.nix</code> file to declaratively state what you want the service to look like and that you want it to be active.</p> <p>Then you can take this same <code>.nix</code> file, place it on another system, and run System Manager again, and you'll have the service installed in a way that's identical to the first system.</p> <p>The following example demonstrates how to specify a system service and activate it.</p> <p>We're assuming you're using a <code>flake.nix</code> similar to what's found in The Main <code>flake.nix</code> File.</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    systemd.services.say-hello = {\n      description = \"say-hello\";\n      enable = true;\n      wantedBy = [ \"system-manager.target\" ];\n      serviceConfig = {\n        Type = \"oneshot\";\n        RemainAfterExit = true;\n      };\n      script = ''\n        ${lib.getBin pkgs.hello}/bin/hello\n      '';\n    };\n  };\n}\n</code></pre> <p>Note:</p> <p>This line is required in the above example:</p> <pre><code>wantedBy = [ \"system-manager.target\" ];\n</code></pre> <p>(There are other options for <code>wantedBy</code>; we discuss it in full under Specifying <code>wantedBy</code> Setting)</p> <p>Activate it using the same nix command as earlier:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake . --sudo\n</code></pre> <p>This will create a system service called <code>say-hello</code> (the name comes from the line <code>systemd.services.say-hello</code>) in a unit file at <code>/etc/systemd/system/say-hello.service</code> with the following inside it:</p> <pre><code>[Unit]\nDescription=say-hello\n\n[Service]\nEnvironment=\"PATH=/nix/store/xs8scz9w9jp4hpqycx3n3bah5y07ymgj-coreutils-9.8/bin:/nix/store/qqvfnxa9jg71wp4hfg1l63r4m78iwvl9-findutils-4.10.0/bin:/nix/store/22r4s6lqhl43jkazn51f3c18qwk894g4-gnugrep-3.12/bin:\n/nix/store/zppkx0lkizglyqa9h26wf495qkllrjgy-gnused-4.9/bin:/nix/store/g48529av5z0vcsyl4d2wbh9kl58c7p73-systemd-minimal-258/bin:/nix/store/xs8scz9w9jp4hpqycx3n3bah5y07ymgj-coreutils-9.8/sbin:/nix/store/qqvfn\nxa9jg71wp4hfg1l63r4m78iwvl9-findutils-4.10.0/sbin:/nix/store/22r4s6lqhl43jkazn51f3c18qwk894g4-gnugrep-3.12/sbin:/nix/store/zppkx0lkizglyqa9h26wf495qkllrjgy-gnused-4.9/sbin:/nix/store/g48529av5z0vcsyl4d2wbh9\nkl58c7p73-systemd-minimal-258/sbin\"\nExecStart=/nix/store/d8rjglbhinylg8v6s780byaa60k6jpz1-unit-script-say-hello-start/bin/say-hello-start\nRemainAfterExit=true\nType=oneshot\n\n[Install]\nWantedBy=system-manager.target\n</code></pre> <p>Tip</p> <p>Compare the lines in the <code>say-hello.service</code> file with the <code>say_hello.nix</code> file to see where each comes from.</p> <p>You can verify that it ran by running <code>journalctl</code>:</p> <pre><code>journalctl -n 20\n</code></pre> <p>and you can find the following output in it:</p> <pre><code>Nov 18 12:12:51 my-ubuntu systemd[1]: Starting say-hello.service - say-hello...\nNov 18 12:12:51 my-ubuntu say-hello-start[3488278]: Hello, world!\nNov 18 12:12:51 my-ubuntu systemd[1]: Finished say-hello.service - say-hello.\n</code></pre> <p>Note</p> <p>If you remove the <code>./apps.nix</code> line from <code>flake.nix</code>, System Manager will see that the configuration changed and that the apps listed in it are no longer in the configuration. As such, it will uninstall them. This is normal and expected behavior.</p>"},{"location":"reference/modules/#specifying-the-wantedby-setting","title":"Specifying the <code>wantedBy</code> Setting","text":"<p>The <code>wantedBy</code> attribute tells systemd when to automatically start a service. System Manager includes its own systemd target that you can use in the <code>wantedBy</code> setting to automatically start any services immediately after applying the changes, as well as after reboot. Here's an example <code>wantedBy</code> line in a <code>.nix</code> configuration file:</p> <pre><code>wantedBy = [ \"system-manager.target\" ];\n</code></pre> <p>(By allowing the service to start after applying changes, you don't need to reboot for the service to start.)</p> <p>But you're not limited to just this target. For example, if you're creating a system service that runs on a schedule, you might use this:</p> <pre><code>wantedBy = [ \"timers.target\" ]\n</code></pre>"},{"location":"reference/modules/#managing-software-installations","title":"Managing Software Installations","text":"<p>System Manager allows you to install software in a fully declarative way similar to installing system services. Instead of relying on a traditional package manager and running commands like <code>apt install</code> or <code>dnf install</code>, you list the packages you want in your configuration file. During a switch, System Manager builds a new system profile that includes those packages, activates it, and ensures the software is available on your <code>PATH</code>. This makes installations reproducible and version-controlled. If you reinstall your operating system or set up a new machine, the exact same tools will appear automatically. And because software installation is tied to your configuration (not to manual actions), System Manager prevents drift--no forgotten tools, no mismatched versions across machines, and no surprises when you rollback or update.</p> <p>Note</p> <p>To install software, you add attributes to the <code>config.environment.systemPackages</code> attribute set.</p>"},{"location":"reference/modules/#example-installing-a-couple-apps","title":"Example: Installing a couple apps","text":"<p>Starting with a flake such as this:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        # Specify your system configuration modules here, for example,\n        # the path to your system.nix.\n        modules = [\n          ./apps.nix\n        ];\n      };\n    };\n}\n</code></pre> <p>Notice this flake references a file called <code>apps.nix</code>. In that file we'll add to the <code>systemPackages</code> attribute. Here's the <code>apps.nix</code> file:</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.hello\n        pkgs.bat\n      ];\n    };\n  };\n}\n</code></pre> <p>When you run System Manager, you should have the packages <code>hello</code> and <code>bat</code> available.</p> <pre><code>$ which hello\n/run/system-manager/sw/bin//hello\n$ which bat\n/run/system-manager/sw/bin//bat\n</code></pre> <p>Note</p> <p>The first time you install an app through System Manager, System Manager will add a file inside <code>/etc/profile.d/</code>. This file adds <code>/run/system-manager/sw/bin/</code> to a user's path when they log in. If this is the first time you've installed an app on this system with System Manager, you'll need to either source that file, or simply log out and log back in.</p> <p>If you prefer, you can combine the above two <code>.nix</code> files into a single flake:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        modules = [\n          ({ lib, pkgs, ... }: {\n            config = {\n              nixpkgs.hostPlatform = \"x86_64-linux\";\n              environment.systemPackages = [\n                pkgs.hello\n                pkgs.bat\n              ];\n            };\n          })\n        ];\n      };\n    };\n}\n</code></pre>"},{"location":"reference/modules/#working-with-etc-files-declaratively","title":"Working With <code>/etc</code> Files Declaratively","text":"<p>Many applications and services rely on configuration files stored under <code>/etc</code>, and System Manager lets you manage those files declaratively as well. Instead of manually editing files like <code>/etc/some_config</code>, you define them in your Nix configuration and let System Manager write them during a switch. This ensures that your system state is always consistent with your configuration and avoids accidental edits or configuration drift. If you ever rebuild your machine, those files are recreated exactly as before, including permissions, contents, and paths. And because System Manager keeps previous generations, you can safely roll back to earlier versions of <code>/etc</code> files if needed. Declarative <code>/etc</code> management is especially powerful in shared or multi-machine environments, where consistency and repeatability matter most.</p> <p>Oftentimes, when you're creating a system service, you need to create a configuration file in the <code>/etc</code> directory that accompanies the service. System Manager allows you to do that as well.</p> <p>Note</p> <p>To install software, you add attributes to the <code>config.environment.etc</code> attribute set.</p>"},{"location":"reference/modules/#example-creating-a-file-in-etc","title":"Example: Creating a file in <code>/etc</code>","text":"<p>Starting with a flake such as this:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        modules = [\n          ./files1.nix\n        ];\n      };\n    };\n}\n</code></pre> <p>Notice this references a file called <code>files1.nix</code>. To create files, you add attributes to the <code>config.environment.etc</code> attribute set as follows:</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    environment = {\n      etc = {\n        \"test/test2/something.txt\" = {\n          text = ''\n            This is just a test!!\n          '';\n          mode = \"0755\";\n          user = \"ubuntu\";\n          group = \"ubuntu\";\n        };\n      };\n    };\n  };\n}\n</code></pre> <p>This creates a single file inside the folder <code>/etc/test/test2/</code> called <code>something.txt</code>.</p> <p>After running the above with System Manager, you can verify the file exists:</p> <pre><code>$ cat /etc/test/test2/something.txt\nThis is just a test!!\n</code></pre> <p>Note that if you prefer, you can combine the above flake and separate <code>.nix</code> file into a single flake like so:</p> <pre><code>{\n  description = \"Standalone System Manager configuration\";\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        modules = [\n          {\n            config.nixpkgs.hostPlatform = \"x86_64-linux\";\n            config.environment.etc.\"test/test2/something.txt\" = {\n                text = ''\n                  This is just a test!!!\n                '';\n                mode = \"0755\";\n                user = \"ubuntu\";\n                group = \"ubuntu\";\n            };\n          }\n        ];\n      };\n    };\n}\n</code></pre>"},{"location":"reference/modules/#permissions","title":"Permissions","text":"<p>NixOS uses the standard modes of file permissions, consisting of three octal digits; the first represents the user; the second represents the group; the third represents all other users (sometimes called \"world\" or \"others\").</p> <p>Each digit is the sum of the permissions it grants:</p> <ul> <li>4 = read (r)</li> <li>2 = write (w)</li> <li>1 = execute (x)</li> </ul> <p>So \"0755\" means:</p> <ul> <li>7 (4+2+1) = owner can read, write, and execute</li> <li>5 (4+1) = group can read and execute</li> <li>5 (4+1) = others can read and execute</li> </ul> <p>Common examples:</p> <p>\"0644\" = owner can read/write, everyone else can only read</p> <p>\"0755\" = owner can do everything, everyone else can read and execute</p> <p>\"0400\" = owner can only read, nobody else can do anything</p> <p>\"0600\" = owner can read/write, nobody else can touch it</p>"},{"location":"reference/modules/#users-and-groups","title":"Users and Groups","text":"<p>To specify a user and group as owners for a file, you can either use the user ID and group ID, or the user name and group name. Here's an example that uses user ID and group ID (notice we set <code>uid</code> and <code>gid</code>):</p> <pre><code>with_ownership = {\n  text = ''\n    This is just a test!\n  '';\n  mode = \"0755\";\n  uid = 5;\n  gid = 6;\n};\n</code></pre> <p>And here's an example that uses named user and group (notice we set <code>user</code> and <code>group</code>):</p> <pre><code>with_ownership2 = {\n  text = ''\n    This is just a test!\n  '';\n  mode = \"0755\";\n  user = \"nobody\";\n  group = \"users\";\n};\n</code></pre> <p>Tip</p> <p>This use of <code>uid</code>/<code>gid</code> for numeric IDs and <code>user</code>/<code>group</code> for names aligns with NixOS standards.</p>"},{"location":"reference/modules/#supporting-system-services-with-tmp-files-and-folders","title":"Supporting System Services with tmp files and folders","text":"<p>Some systemd services need runtime directories, temporary files, or specific filesystem structures to exist before they can start. The <code>systemd.tmpfiles</code> configuration provides a declarative way to create these files and directories, set their permissions and ownership, and manage cleanup policies. This is particularly useful for volatile directories like those under <code>/var/run/</code>, <code>/tmp/</code>, or custom application directories that need to be recreated on each boot with the correct permissions.</p> <p>For example, if you're running a web application that stores temporary uploads in <code>/var/app/uploads/</code>, you can use tmpfiles to ensure this directory exists with the correct permissions when the system boots. Without tmpfiles, your service might fail to start because the directory doesn't exist yet, or it might have the wrong ownership and your application can't write to it.</p> <p>For this we offer two distinct syntaxes you can use, depending on your needs, as shown in the following sample code:</p> <pre><code>    # Configure systemd tmpfile settings\n    systemd.tmpfiles = {\n       rules = [\n         \"D /var/tmp/system-manager 0755 root root -\"\n       ];\n\n       settings.sample = {\n         \"/var/tmp/sample\".d = {\n           mode = \"0755\";\n         };\n       };\n    };\n</code></pre> <p>The first example (<code>rules</code>), creates a directory called <code>/var/tmp/system-manager</code> with mode <code>0755</code>, owned by user root and group root. (The <code>-</code> means no age-based cleanup.)</p> <p>The second example creates the same type of directory at <code>/var/tmp/sample</code> with mode <code>0755</code>, but uses the structured <code>settings</code> format. Since user and group aren't specified, they default to root. This Nix-friendly syntax is more readable and easier to maintain than raw <code>tmpfiles.d</code> strings.</p>"},{"location":"reference/remote-flakes/","title":"Remote Flakes","text":"<p>Instead of saving your System Manager configuration files locally, you can optionally keep them in a remote Git repository, such as on GitHub.</p> <p>Note</p> <p>This is a great option if you plan to use the files on multiple machines.</p> <p>In order to store them on a remote repo, it's imperative that you keep your <code>flake.lock</code> file up to date.</p>"},{"location":"reference/remote-flakes/#whats-a-flakelock-file","title":"What's a <code>flake.lock</code> file?","text":"<p>A <code>flake.lock</code> file is a JSON file that stores the exact versions of all the inputs your flake file depends on, including things like nixpkgs, System Manager itself, and anything else you might import. Instead of pulling the latest version every time you build, the lock file ensures that the same inputs are used consistently across machines and over time. This makes your configuration reproducible, stable, and rollback-friendly. When you do want to update to new versions, you run a command like <code>nix flake update</code>, which refreshes the lock file in a controlled way.</p>"},{"location":"reference/remote-flakes/#setting-up-your-project-for-remote-hosting","title":"Setting up your project for remote hosting","text":"<p>As you create your flake.nix and set up any supporting files, you'll want to test it out thoroughly before pushing it up to a remote repo.</p> <p>For this you have a couple options; one is to test it out on the machine you're currently using. However, we recommend against this, as there might be artifacts on your computer that can interfere with the configuration.</p> <p>Instead, we recommend starting with a fresh machine. One option is to spin up an EC2 instance on AWS; another is to open up a Virtual Box session on your computer.</p> <p>Important</p> <p>You'll need to ensure you have at least 16GB of disk space on the virtual machine. If you go with 8GB, you're going to run out of space.</p> <p>After starting with a fresh machine, install Nix, copy over your <code>flake.nix</code> and supporting files, and test it out. Once you're ready, make sure your <code>flake.lock</code> file is up to date. You can create or update the <code>flake.lock</code> file by typing:</p> <pre><code>nix flake update\n</code></pre> <p>And make sure you've pushed it up to the repo. (If you don't do this step, Nix will try to build a <code>flake.lock</code>, but will be unable to write it to the same location as the other files, and will error out.)</p> <pre><code>nix run 'github:numtide/system-manager' --extra-experimental-features 'nix-command flakes' -- switch --flake git+https://github.com/numtide/system-manager-test#default --sudo\n</code></pre>"},{"location":"reference/remote-flakes/#when-should-you-update-your-flakelock-file","title":"When should you update your <code>flake.lock</code> file?","text":"<p>Generally, you only need to update your <code>flake.lock</code> file when you want newer versions of your inputs (nixpkgs, etc). Updating isn't necessary for daily use; your configuration will continue to work with the locked versions. But you will want to update your <code>flake.lock</code> file in cases such as:</p> <ul> <li>You want newer package versions (e.g. newer <code>btop</code>, etc.)</li> <li>You want security patches</li> <li>You've added new inputs to your flakes (in which case you'll be required to update <code>flake.lock</code>)</li> <li>You're preparing a fresh install and decide this is a good time to upgrade everything</li> </ul>"},{"location":"reference/remote-flakes/#cant-system-manager-build-flakelock-for-me","title":"Can't System Manager build <code>flake.lock</code> for me?","text":"<p>Yes, but only if the <code>flake.nix</code> file is local to your machine. The problem is System Manager will try to write a <code>flake.lock</code> file in the same location as the <code>flake.nix</code> file, which isn't possible (at this time) with a GitHub repo.</p>"},{"location":"reference/remote-flakes/#ensuring-success","title":"Ensuring success","text":"<p>In order to ensure System Manager retrieves the correct <code>.nix</code> files from your repo, we recommend including either a branch or a tag along with your repo.</p>"},{"location":"reference/remote-flakes/#running-system-manager-with-a-remote-flake","title":"Running System Manager with a remote flake","text":"<p>Tip</p> <p>Before you run this command, we recommend that you nevertheless create a folder to run it from, such as <code>~/.config/system-manager</code>.</p> <p>Once your configuration is pushed to a remote repository with a valid <code>flake.lock</code>, you can apply it directly:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake github:your-username/your-repo --sudo\n</code></pre> <p>You can also specify a branch or tag:</p> <pre><code># Using a specific branch\nnix run 'github:numtide/system-manager' -- switch --flake github:your-username/your-repo/main --sudo\n\n# Using a tag\nnix run 'github:numtide/system-manager' -- switch --flake github:your-username/your-repo?ref=v1.0.0 --sudo\n</code></pre> <p>For private repositories, use the <code>git+ssh</code> protocol:</p> <pre><code>nix run 'github:numtide/system-manager' -- switch --flake git+ssh://git@github.com/your-username/your-repo --sudo\n</code></pre>"},{"location":"reference/examples/","title":"Examples","text":"<p>Complete, working examples demonstrating System Manager configurations for common use cases.</p>"},{"location":"reference/examples/#available-examples","title":"Available Examples","text":""},{"location":"reference/examples/#timer","title":"Timer","text":"<p>Create a simple systemd timer that runs every minute, demonstrating how to set up scheduled tasks.</p>"},{"location":"reference/examples/#docker","title":"Docker","text":"<p>Install Docker and configure it as a systemd service with proper socket activation and daemon configuration.</p>"},{"location":"reference/examples/#postgresql","title":"PostgreSQL","text":"<p>Set up a PostgreSQL database server with automatic initialization, user creation, and proper systemd integration.</p>"},{"location":"reference/examples/#nginx","title":"Nginx","text":"<p>Configure Nginx as a web server with HTTP support, including systemd service management and <code>/etc</code> configuration.</p>"},{"location":"reference/examples/#nginx-https","title":"Nginx HTTPS","text":"<p>Extend the Nginx configuration with SSL/TLS certificates for HTTPS support, including certificate management and security best practices.</p>"},{"location":"reference/examples/#custom-app","title":"Custom App","text":"<p>Deploy a custom TypeScript/Bun application behind Nginx, demonstrating how to fetch code from GitHub and run it as a systemd service. Includes a live example you can try.</p>"},{"location":"reference/examples/custom-app/","title":"Custom App","text":"<p>This example shows how to deploy custom web software from a repository and run it behind Nginx.</p>"},{"location":"reference/examples/custom-app/#live-example","title":"Live example","text":"<p>We have a complete example live that you can try out. All you need is a fresh server (such as on Amazon EC2) with at least 16GB memory. (We recommend the latest Ubuntu, with a t3Large instance, with 16GB RAM. Then allow SSH, HTTP traffic, and HTTPS traffic if you plan to build on these examples.) We have two repos:</p> <ol> <li> <p>The sample application</p> </li> <li> <p>The configuration files</p> </li> </ol> <p>The configuration files install both nginx and the sample app.</p> <p>After you spin up an instance, install nix for all users:</p> <pre><code>sh &lt;(curl --proto '=https' --tlsv1.2 -L https://nixos.org/nix/install) --daemon\n</code></pre> <p>Next, log out and log back in so that nix is available in the system path.</p> <p>And then you can run System Manager and deploy the app with one command:</p> <pre><code>nix run 'github:numtide/system-manager' --extra-experimental-features 'nix-command flakes' -- switch --flake github:frecklefacelabs/system-manager-custom-app-deploy/v1.0.0#default --sudo\n</code></pre> <p>(Remember, the first time System Manager runs, it takes up to five minutes or so to compile everything.)</p> <p>Tip</p> <p>We're specifying a tag in our URL. This is good practice to make sure you get the right version of your flakes. Also, modern Nix supports the use of a protocol called \"github\", and when you use that protocol, you can specify the tag behind a slash symbol, as we did here for tag v1.0.0.</p> <p>Tip</p> <p>If you make changes to your flakes, be sure to create a new tag. Without it, Nix sometimes refuses to load the \"latest version\" of the repo, and will insist on using whatever version of your repo it used first.</p> <p>Then, the app should be installed, with nginx sitting in front of it, and you should be able to run:</p> <p><pre><code>curl localhost\n</code></pre> And it will print out a friendly JSON message such as:</p> <pre><code>{\"message\":\"Welcome to the Bun API!\",\"status\":\"running\",\"endpoints\":[\"/\",\"/health\",\"/random\",\"/cowsay\"]}\n</code></pre> <p>We even included cowsay in this sample, which you can try at <code>curl localhost/cowsay</code>. Now even though cowsay is meant for fun, the primary reason is this is a TypeScript app that uses <code>bun</code>, and we wanted to demonstrate how easy it is to include <code>npm</code> libraries. <code>bun</code> includes a feature whereby it will install dependency packages from <code>package.json</code> automatically the first time it runs, greatly simplifying the setup.</p> <p>One thing about the <code>.nix</code> files in this repo is that they in turn pull code (our TypeScript app) from another remote repo. Using this approach, you can separate concerns, placing the deployment <code>.nix</code> files in one repo, and the source app in a separate repo.</p>"},{"location":"reference/examples/custom-app/#configuration-files","title":"Configuration files","text":"<p>Here are further details on the individual <code>.nix</code> files.</p>"},{"location":"reference/examples/custom-app/#flakenix","title":"flake.nix","text":"<p>First we have a flake much like the usual starting point:</p> <pre><code># flake.nix\n{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n\n        # Specify your system configuration modules here, for example,\n        # the path to your system.nix.\n        modules = [\n\n          {\n            nix.settings.experimental-features = \"nix-command flakes\";\n            services.myapp.enable = true;\n          }\n            ./system.nix\n            ./nginx.nix\n            ./bun-app.nix\n        ];\n\n        # Optionally specify extraSpecialArgs and overlays\n      };\n    };\n}\n</code></pre>"},{"location":"reference/examples/custom-app/#nginxnix","title":"nginx.nix","text":"<p>Next is the <code>.nix</code> configuration that installs and configures nginx. This is a simple nginx configuration, as it simply routes incoming HTTP traffic directly to the app:</p> <pre><code># nginx.nix\n{ config, lib, pkgs, ... }:\n{\n  config = {\n    services.nginx = {\n      enable = true;\n\n      recommendedGzipSettings = true;\n      recommendedOptimisation = true;\n      recommendedProxySettings = true;\n      recommendedTlsSettings = true;\n\n      virtualHosts.\"_\" = {\n        default = true;\n\n        locations.\"/\" = {\n          proxyPass = \"http://127.0.0.1:3000\";\n          extraConfig = ''\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n          '';\n        };\n\n        locations.\"/health\" = {\n          proxyPass = \"http://127.0.0.1:3000/health\";\n          extraConfig = ''\n            access_log off;\n          '';\n        };\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/custom-app/#bun-appnix","title":"bun-app.nix","text":"<p>Next, here's the <code>.nix</code> configuration that creates a service that runs the app.</p> <pre><code># bun-app.nix\n{ config, lib, pkgs, ... }:\nlet\n  # Fetch the app from GitHub\n  appSource = pkgs.fetchFromGitHub {\n    owner = \"frecklefacelabs\";\n    repo = \"typescript_app_for_system_manager\";\n    rev = \"v1.0.0\";  # Use a tag\n    sha256 = \"sha256-TWt/Y2B7cGxjB9pxMOApt83P29uiCBv5nVT3KyycYEA=\";\n  };\nin\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    # Install Bun\n    environment.systemPackages = with pkgs; [\n      bun\n    ];\n\n    # Simple systemd service - runs Bun directly from Nix store!\n    systemd.services.bunapp = {\n      description = \"Bun TypeScript Application\";\n      after = [ \"network.target\" ];\n      wantedBy = [ \"multi-user.target\" ];\n\n      serviceConfig = {\n        Type = \"simple\";\n        User = \"ubuntu\";\n        Group = \"ubuntu\";\n        WorkingDirectory = \"${appSource}\";\n        # Bun will auto-install dependencies from package.json on first run\n        ExecStart = \"${pkgs.bun}/bin/bun run index.ts\";\n        Restart = \"always\";\n        RestartSec = \"10s\";\n      };\n\n      environment = {\n        NODE_ENV = \"production\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/custom-app/#indexts-the-application","title":"index.ts (The application)","text":"<p>And finally, here's the <code>index.ts</code> file; it's just a simple REST app that also makes use of one third-party <code>npm</code> library.</p> <pre><code>import cowsay from \"cowsay\";\n\nconst messages = [\n  \"Hello from System Manager!\",\n  \"Bun is blazingly fast!\",\n  \"Nix + Bun = Easy deployments\",\n  \"Making it happen!\",\n  \"Nix rocks!\"\n];\n\nconst server = Bun.serve({\n  port: 3000,\n  fetch(req) {\n    const url = new URL(req.url);\n\n    if (url.pathname === \"/\") {\n      return new Response(JSON.stringify({\n        message: \"Welcome to the Bun API!\",\n        status: \"running\",\n        endpoints: [\"/\", \"/health\", \"/random\", \"/cowsay\"]\n      }), {\n        headers: { \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    if (url.pathname === \"/health\") {\n      return new Response(JSON.stringify({\n        status: \"healthy\"\n      }), {\n        headers: { \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    if (url.pathname === \"/random\") {\n      const randomMessage = messages[Math.floor(Math.random() * messages.length)];\n      return new Response(JSON.stringify({\n        message: randomMessage,\n        timestamp: new Date().toISOString()\n      }), {\n        headers: { \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    if (url.pathname === \"/cowsay\") {\n      const cow = cowsay.say({\n        text: \"Deployed with System Manager and Nix!\"\n      });\n      return new Response(cow, {\n        headers: { \"Content-Type\": \"text/plain\" }\n      });\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  },\n});\n\nconsole.log(`Server running on http://localhost:${server.port}`);\n</code></pre>"},{"location":"reference/examples/custom-app/#what-this-configuration-does","title":"What this configuration does","text":"<ol> <li>Fetches the application from GitHub using <code>pkgs.fetchFromGitHub</code></li> <li>Installs Bun as a system package</li> <li>Creates a systemd service that:</li> <li>Runs the TypeScript app using Bun</li> <li>Automatically restarts on failure</li> <li>Sets the working directory to the fetched source</li> <li>Configures Nginx as a reverse proxy to the app on port 3000</li> </ol>"},{"location":"reference/examples/custom-app/#key-concepts","title":"Key concepts","text":"<ul> <li>Separation of concerns: The deployment configuration (<code>.nix</code> files) lives in one repo, while the application source lives in another</li> <li>Automatic dependency installation: Bun installs npm dependencies from <code>package.json</code> on first run</li> <li>Reproducible deployments: The <code>sha256</code> hash ensures you get the exact version you expect</li> </ul>"},{"location":"reference/examples/docker/","title":"Docker","text":"<p>This example shows how to install Docker and configure it as a systemd service.</p>"},{"location":"reference/examples/docker/#configuration","title":"Configuration","text":"<pre><code>{\n  description = \"System Manager - Docker Example\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = { self, nixpkgs, system-manager }: {\n    systemConfigs.default = system-manager.lib.makeSystemConfig {\n      modules = [\n        {\n          nixpkgs.hostPlatform = \"x86_64-linux\";\n\n          # Install Docker and related tools\n          environment.systemPackages = with nixpkgs.legacyPackages.x86_64-linux; [\n            docker\n            docker-compose\n            docker-buildx\n          ];\n\n          # Docker daemon configuration\n          environment.etc.\"docker/daemon.json\".text = ''\n            {\n              \"log-driver\": \"json-file\",\n              \"log-opts\": {\n                \"max-size\": \"10m\",\n                \"max-file\": \"3\"\n              },\n              \"storage-driver\": \"overlay2\",\n              \"storage-opts\": [\n                \"overlay2.override_kernel_check=true\"\n              ]\n            }\n          '';\n\n          # Create Docker systemd service\n          systemd.services.docker = {\n            enable = true;\n            description = \"Docker Application Container Engine\";\n            documentation = [ \"https://docs.docker.com\" ];\n            after = [ \"network-online.target\" \"firewalld.service\" \"containerd.service\" ];\n            wants = [ \"network-online.target\" ];\n            requires = [ \"docker.socket\" ];\n            wantedBy = [ \"system-manager.target\" ];\n\n            serviceConfig = {\n              Type = \"notify\";\n              ExecStart = \"${nixpkgs.legacyPackages.x86_64-linux.docker}/bin/dockerd --host=fd://\";\n              ExecReload = \"/bin/kill -s HUP $MAINPID\";\n              TimeoutStartSec = 0;\n              RestartSec = 2;\n              Restart = \"always\";\n              StartLimitBurst = 3;\n              StartLimitInterval = \"60s\";\n\n              # Security settings\n              LimitNOFILE = 1048576;\n              LimitNPROC = \"infinity\";\n              LimitCORE = \"infinity\";\n              TasksMax = \"infinity\";\n              Delegate = \"yes\";\n              KillMode = \"process\";\n              OOMScoreAdjust = -500;\n            };\n          };\n\n          # Docker socket\n          systemd.sockets.docker = {\n            enable = true;\n            description = \"Docker Socket for the API\";\n            wantedBy = [ \"sockets.target\" ];\n\n            socketConfig = {\n              ListenStream = \"/var/run/docker.sock\";\n              SocketMode = \"0660\";\n              SocketUser = \"root\";\n              SocketGroup = \"docker\";\n            };\n          };\n\n          # Create necessary directories and setup\n          systemd.tmpfiles.rules = [\n            \"d /var/lib/docker 0710 root root -\"\n            \"d /var/run/docker 0755 root root -\"\n            \"d /etc/docker 0755 root root -\"\n          ];\n        }\n      ];\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/docker/#usage","title":"Usage","text":"<pre><code># Activate the configuration\nnix run 'github:numtide/system-manager' -- switch --flake /path/to/this/example --sudo\n\n# Check Docker service status\nsudo systemctl status docker\n\n# Test Docker\nsudo docker run hello-world\n\n# Check Docker version\nsudo docker --version\n\n# View Docker logs\nsudo journalctl -u docker -f\n</code></pre>"},{"location":"reference/examples/docker/#notes","title":"Notes","text":"<ul> <li>Ensure the <code>docker</code> group exists on your system</li> <li>Add your user to the docker group: <code>sudo usermod -aG docker $USER</code></li> <li>You may need to log out and back in for group changes to take effect</li> <li>This example uses the Docker socket for API communication</li> </ul>"},{"location":"reference/examples/nginx-https/","title":"Nginx HTTPS","text":"<p>This example shows how to install Nginx with HTTPS support using SSL certificates.</p>"},{"location":"reference/examples/nginx-https/#configuration","title":"Configuration","text":"<p>Here's an example that installs nginx with HTTPS. This example shows places where you would copy in your own secure certificate information.</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    # Enable and configure services\n    # Commenting this out -- apparently this loads a bunch of nginx service files we don't need or want\n    #services = {\n    #  nginx.enable = true;\n    #};\n\n    environment = {\n      systemPackages = [\n        pkgs.hello\n        pkgs.mariadb\n        pkgs.nginx\n      ];\n\n      # Add SSL certificate files to /etc\n      etc = {\n        # SSL Certificate\n        \"ssl/certs/your-domain.crt\" = {\n          user = \"root\";\n          group = \"root\";\n          mode = \"0644\";\n          # Option 1: Embed the certificate directly\n          text = ''\n-----BEGIN CERTIFICATE-----\nMIIDwzCCAqugAwIBAgIUXbQ2ie2/2pxLH/okEB4KEbVDqjEwDQYJKoZIhvcNAQEL...\n-----END CERTIFICATE-----\n          '';\n          # Option 2: Or reference a file from your repo\n          # source = ./certs/your-domain.crt;\n        };\n\n        # SSL Private Key\n        \"ssl/private/your-domain.key\" = {\n          user = \"root\";\n          group = \"root\";\n          mode = \"0600\";  # Restrict access to private key!\n          # Option 1: Embed the key directly\n          text = ''\n-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC5gQjZxG7rYPub....\n-----END PRIVATE KEY-----\n          '';\n          # Option 2: Or reference a file from your repo\n          # source = ./certs/your-domain.key;\n        };\n\n        # Optional: Certificate chain/intermediate certificates\n        # For this demo we're using a self-signed cert; for a real\n        # one, uncomment below and add your\n        \"ssl/certs/chain.pem\" = {\n          user = \"root\";\n          group = \"root\";\n          mode = \"0644\";\n          text = ''\n            -----BEGIN CERTIFICATE-----\nYOUR_CHAIN_CERTIFICATE_HERE...\n            -----END CERTIFICATE-----\n          '';\n        #};\n\n        # Nginx configuration with HTTPS\n        \"nginx/nginx.conf\" = {\n          user = \"root\";\n          group = \"root\";\n          mode = \"0644\";\n          text = ''\nworker_processes auto;\n\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    include             ${pkgs.nginx}/conf/mime.types;\n    default_type        application/octet-stream;\n\n    sendfile            on;\n    keepalive_timeout   65;\n\n    # SSL Settings\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';\n\n    # HTTP Server - Redirect to HTTPS\n    server {\n        listen 80;\n        server_name demo.frecklefacelabs.com www.demo.frecklefacelabs.com;\n\n        # Redirect all HTTP to HTTPS\n        return 301 https://$server_name$request_uri;\n    }\n\n    # HTTPS Server\n    server {\n        listen 443 ssl;\n        server_name demo.frecklefacelabs.com www.demo.frecklefacelabs.com;\n\n        # SSL Certificate files\n        ssl_certificate /etc/ssl/certs/your-domain.crt;\n        ssl_certificate_key /etc/ssl/private/your-domain.key;\n\n        # Optional: Certificate chain\n        # ssl_trusted_certificate /etc/ssl/certs/chain.pem;\n\n        # Optional: Enable OCSP stapling\n        ssl_stapling on;\n        ssl_stapling_verify on;\n\n        # Optional: Enable HSTS (HTTP Strict Transport Security)\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n\n        root ${pkgs.nginx}/html;\n\n        location / {\n            index index.html;\n        }\n\n        access_log /var/log/nginx/access.log;\n        error_log /var/log/nginx/error.log;\n    }\n}\n          '';\n        };\n      };\n    };\n\n    systemd.services = {\n      nginx = {\n        enable = true;\n        #description = \"A high performance web server and reverse proxy server\";\n        wantedBy = [ \"system-manager.target\" ];\n        preStart = ''\n          mkdir -p /var/log/nginx\n          chown -R root:root /var/log/nginx\n\n          # Verify SSL certificate files exist\n          if [ ! -f /etc/ssl/certs/your-domain.crt ]; then\n            echo \"ERROR: SSL certificate not found!\"\n            exit 1\n          fi\n          if [ ! -f /etc/ssl/private/your-domain.key ]; then\n            echo \"ERROR: SSL private key not found!\"\n            exit 1\n          fi\n        '';\n        serviceConfig = {\n          Type = \"forking\";\n          PIDFile = \"/run/nginx.pid\";\n          ExecStart = \"${pkgs.nginx}/bin/nginx -c /etc/nginx/nginx.conf\";\n          ExecStop = \"${pkgs.nginx}/bin/nginx -s stop\";\n          User = \"root\";\n          Group = \"root\";\n          Restart = \"on-failure\";\n        };\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/nginx-https/#what-this-configuration-does","title":"What this configuration does","text":"<ol> <li>Creates SSL certificate files in <code>/etc/ssl/</code>:</li> <li><code>/etc/ssl/certs/your-domain.crt</code> - The public certificate</li> <li><code>/etc/ssl/private/your-domain.key</code> - The private key (with restricted permissions)</li> <li> <p><code>/etc/ssl/certs/chain.pem</code> - Optional intermediate certificates</p> </li> <li> <p>Configures Nginx for HTTPS:</p> </li> <li>Redirects HTTP (port 80) to HTTPS</li> <li>Enables TLS 1.2 and 1.3 only</li> <li>Uses strong cipher suites</li> <li> <p>Enables HSTS for security</p> </li> <li> <p>Creates a systemd service that:</p> </li> <li>Verifies SSL certificates exist before starting</li> <li>Runs Nginx with the HTTPS configuration</li> </ol>"},{"location":"reference/examples/nginx-https/#security-notes","title":"Security notes","text":"<ul> <li>The private key file uses mode <code>0600</code> to restrict access</li> <li>TLS 1.0 and 1.1 are disabled for security</li> <li>HSTS is enabled to enforce HTTPS</li> <li>Replace the placeholder certificate content with your actual certificates</li> </ul>"},{"location":"reference/examples/nginx/","title":"Nginx","text":"<p>This example shows how to install and configure Nginx as a web server with HTTP support.</p> <p>Tip</p> <p>This is simply an example to help you learn how to use System Manager. The usual way to install nginx under Nix is to use the nginx package.</p>"},{"location":"reference/examples/nginx/#configuration","title":"Configuration","text":"<p>Here's a <code>.nix</code> file that installs and configures nginx as a system service. Note that this version only supports HTTP and not HTTPS; see Nginx HTTPS for an example that includes HTTPS.</p> <pre><code>{ lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    # Enable and configure services\n    services = {\n      nginx.enable = true;\n    };\n\n    environment = {\n      # Packages that should be installed on a system\n      systemPackages = [\n        pkgs.hello\n        pkgs.mariadb\n        pkgs.nginx\n      ];\n\n      # Add directories and files to `/etc` and set their permissions\n      etc = {\n        \"nginx/nginx.conf\"= {\n\n                user = \"root\";\n                group = \"root\";\n                mode = \"0644\";\n\n                text = ''\n# The user/group is often set to 'nginx' or 'www-data',\n# but for a simple root-only demo, we'll keep the default.\n# user nginx;\nworker_processes auto;\n\n# NGINX looks for modules relative to the install prefix,\n# but we explicitly point to the Nix store path to be safe.\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    include             ${pkgs.nginx}/conf/mime.types;\n    default_type        application/octet-stream;\n\n    sendfile            on;\n    keepalive_timeout   65;\n\n    # Basic default server block\n    server {\n        listen 80;\n        server_name localhost;\n\n        # Point the root directory to a standard location or a Nix store path\n        root ${pkgs.nginx}/html;\n\n        location / {\n            index index.html;\n        }\n\n        # Example log files\n        access_log /var/log/nginx/access.log;\n        error_log /var/log/nginx/error.log;\n    }\n}\n    '';\n\n\n        };\n      };\n    };\n\n    # Enable and configure systemd services\n    systemd.services = {\n        nginx = {\n            enable = true;\n            description = \"A high performance web server and reverse proxy server\";\n            wantedBy = [ \"system-manager.target\" ];\n            preStart = ''\n                mkdir -p /var/log/nginx\n                chown -R root:root /var/log/nginx # Ensure permissions are right for root user\n            '';\n            serviceConfig = {\n                Type = \"forking\";\n                PIDFile = \"/run/nginx.pid\";\n\n                # The main binary execution command, pointing to the Nix store path\n                ExecStart = \"${pkgs.nginx}/bin/nginx -c /etc/nginx/nginx.conf\";\n\n                # The command to stop the service gracefully\n                ExecStop = \"${pkgs.nginx}/bin/nginx -s stop\";\n\n                # NGINX needs to run as root to bind to port 80/443\n                User = \"root\";\n                Group = \"root\";\n\n                # Restart policy for robustness\n                Restart = \"on-failure\";\n            };\n        };\n    };\n\n\n  };\n}\n</code></pre>"},{"location":"reference/examples/nginx/#what-this-configuration-does","title":"What this configuration does","text":"<ol> <li>Installs Nginx as a system package</li> <li>Creates <code>/etc/nginx/nginx.conf</code> with a basic HTTP configuration</li> <li>Creates a systemd service that:</li> <li>Creates the log directory on startup</li> <li>Runs Nginx with the custom configuration</li> <li>Restarts on failure</li> <li>Serves the default Nginx welcome page on port 80</li> </ol>"},{"location":"reference/examples/postgresql/","title":"PostgreSQL","text":"<p>This example shows how to install and configure PostgreSQL as a systemd service.</p>"},{"location":"reference/examples/postgresql/#prerequisites","title":"Prerequisites","text":"<p>System Manager is still in its early state, and doesn't yet have user management, which is a planned feature that will be here soon. As such, for now, before you run this, you'll need to manually create the postgres user. Additionally, go ahead and create two directories and grant the postgres user access to them:</p> <pre><code># Create postgres user and group\nsudo groupadd -r postgres\nsudo useradd -r -g postgres -d /var/lib/postgresql -s /bin/bash postgres\n\n# Create directories with proper permissions\nsudo mkdir -p /var/lib/postgresql\nsudo chown postgres:postgres /var/lib/postgresql\n\nsudo mkdir -p /run/postgresql\nsudo chown postgres:postgres /run/postgresql\n</code></pre>"},{"location":"reference/examples/postgresql/#configuration","title":"Configuration","text":"<p>Here's the <code>.nix</code> file that installs PostgreSQL.</p> <pre><code>{ config, lib, pkgs, ... }:\n{\n  config = {\n    nixpkgs.hostPlatform = \"x86_64-linux\";\n\n    environment.systemPackages = with pkgs; [\n      postgresql_16\n    ];\n\n    # PostgreSQL service\n    systemd.services.postgresql = {\n      description = \"PostgreSQL database server\";\n      wantedBy = [ \"multi-user.target\" ];\n      after = [ \"network.target\" ];\n\n      serviceConfig = {\n        Type = \"notify\";\n        User = \"postgres\";\n        Group = \"postgres\";\n        ExecStart = \"${pkgs.postgresql_16}/bin/postgres -D /var/lib/postgresql/16\";\n        ExecReload = \"${pkgs.coreutils}/bin/kill -HUP $MAINPID\";\n        KillMode = \"mixed\";\n        KillSignal = \"SIGINT\";\n        TimeoutSec = 120;\n\n        # Create directories and initialize database\n        ExecStartPre = [\n          \"${pkgs.coreutils}/bin/mkdir -p /var/lib/postgresql/16\"\n          \"${pkgs.bash}/bin/bash -c 'if [ ! -d /var/lib/postgresql/16/base ]; then ${pkgs.postgresql_16}/bin/initdb -D /var/lib/postgresql/16; fi'\"\n        ];\n      };\n\n      environment = {\n        PGDATA = \"/var/lib/postgresql/16\";\n      };\n    };\n\n    # Initialize database and user\n    systemd.services.postgresql-init = {\n      description = \"Initialize PostgreSQL database for myapp\";\n      after = [ \"postgresql.service\" ];\n      wantedBy = [ \"multi-user.target\" ];\n      serviceConfig = {\n        Type = \"oneshot\";\n        RemainAfterExit = true;\n        User = \"postgres\";\n      };\n      script = ''\n        # Wait for PostgreSQL to be ready\n        until ${pkgs.postgresql_16}/bin/pg_isready; do\n          echo \"Waiting for PostgreSQL...\"\n          sleep 2\n        done\n\n        # Optional: Create database if it doesn't exist\n        ${pkgs.postgresql_16}/bin/psql -lqt | ${pkgs.coreutils}/bin/cut -d \\| -f 1 | ${pkgs.gnugrep}/bin/grep -qw myapp || \\\n          ${pkgs.postgresql_16}/bin/createdb myapp\n\n        # Optional: Create user if it doesn't exist\n        ${pkgs.postgresql_16}/bin/psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='myapp'\" | ${pkgs.gnugrep}/bin/grep -q 1 || \\\n          ${pkgs.postgresql_16}/bin/createuser myapp\n\n        # Grant database privileges\n        ${pkgs.postgresql_16}/bin/psql -c \"GRANT ALL PRIVILEGES ON DATABASE myapp TO myapp\"\n\n        # Grant schema privileges (allows creating tables!)\n        ${pkgs.postgresql_16}/bin/psql -d myapp -c \"GRANT ALL ON SCHEMA public TO myapp\"\n        ${pkgs.postgresql_16}/bin/psql -d myapp -c \"GRANT ALL ON ALL TABLES IN SCHEMA public TO myapp\"\n        ${pkgs.postgresql_16}/bin/psql -d myapp -c \"GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO myapp\"\n\n        echo \"PostgreSQL is ready and configured!\"\n      '';\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/postgresql/#what-this-configuration-does","title":"What this configuration does","text":"<ol> <li>Installs PostgreSQL 16 as a system package</li> <li>Creates a systemd service that:</li> <li>Runs as the <code>postgres</code> user</li> <li>Initializes the database directory on first run</li> <li>Starts PostgreSQL with the data directory at <code>/var/lib/postgresql/16</code></li> <li>Creates an initialization service that:</li> <li>Waits for PostgreSQL to be ready</li> <li>Creates a database called <code>myapp</code></li> <li>Creates a user called <code>myapp</code></li> <li>Grants appropriate privileges</li> </ol>"},{"location":"reference/examples/timer/","title":"Timer","text":"<p>This example demonstrates how to install a systemd timer that runs every minute.</p>"},{"location":"reference/examples/timer/#configuration","title":"Configuration","text":""},{"location":"reference/examples/timer/#flakenix","title":"flake.nix","text":"<pre><code>{\n  description = \"Standalone System Manager configuration\";\n\n  inputs = {\n    # Specify the source of System Manager and Nixpkgs.\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    system-manager = {\n      url = \"github:numtide/system-manager\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    {\n      self,\n      nixpkgs,\n      system-manager,\n      ...\n    }:\n    let\n      system = \"x86_64-linux\";\n    in\n    {\n      systemConfigs.default = system-manager.lib.makeSystemConfig {\n        # Specify your system configuration modules here, for example,\n        # the path to your system.nix.\n        modules = [ ./system.nix ];\n\n        # Optionally specify extraSpecialArgs and overlays\n      };\n    };\n}\n</code></pre>"},{"location":"reference/examples/timer/#systemnix","title":"system.nix","text":"<pre><code>{ pkgs, ... }:\n{\n  nixpkgs.hostPlatform = \"x86_64-linux\";\n\n  # Define the timer that fires every minute\n  systemd.timers.simple-timer = {\n    enable = true;\n    description = \"Simple timer that runs every minute\";\n    wantedBy = [ \"timers.target\" ];\n    timerConfig = {\n      OnCalendar = \"minutely\";\n      Persistent = true;\n    };\n  };\n\n  # Define the service that the timer triggers\n  systemd.services.simple-timer = {\n    enable = true;\n    description = \"Simple timer service\";\n    serviceConfig = {\n      Type = \"oneshot\";\n      ExecStart = \"${pkgs.bash}/bin/bash -c 'echo \\\"Timer fired at $(date)\\\" &gt;&gt; /tmp/simple-timer.log'\";\n    };\n  };\n}\n</code></pre>"},{"location":"reference/examples/timer/#usage","title":"Usage","text":"<pre><code># Activate the configuration\nnix run 'github:numtide/system-manager' -- switch --flake /path/to/this/example --sudo\n</code></pre> <p>Then restart the system; the timer will start automatically.</p> <pre><code># View the file created every one minute\ncat /tmp/simple-timer.log\n</code></pre>"},{"location":"reference/examples/timer/#notes","title":"Notes","text":"<ul> <li>The timer will not start automatically until you reboot the system. If you wish to start it manually, you can do so by typing:</li> </ul> <pre><code>sudo systemctl start simple-timer.timer\n</code></pre>"}]}